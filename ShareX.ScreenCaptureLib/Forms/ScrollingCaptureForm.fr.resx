<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="tpCapture.Text" xml:space="preserve">
    <value>Capturer</value>
  </data>
  <data name="gbImages.Text" xml:space="preserve">
    <value>Images</value>
  </data>
  <data name="lblTrimLeft.Text" xml:space="preserve">
    <value>Gauche:</value>
  </data>
  <data name="lblTrimRight.Text" xml:space="preserve">
    <value>Droite:</value>
  </data>
  <data name="lblTrimBottom.Text" xml:space="preserve">
    <value>Bas:</value>
  </data>
  <data name="lblTrimTop.Text" xml:space="preserve">
    <value>Haut:</value>
  </data>
  <data name="btnCapture.Text" xml:space="preserve">
    <value>Démarrer la capture avec défilements</value>
  </data>
  <data name="cbRemoveDuplicates.Text" xml:space="preserve">
    <value>Supprimer les images en double</value>
  </data>
  <data name="lblIgnoreLast.Text" xml:space="preserve">
    <value>Supprimer les dernières:</value>
  </data>
  <data name="lblProcessing.Text" xml:space="preserve">
    <value>Traitement en cours ...</value>
  </data>
  <data name="gbCombineAdjustments.Text" xml:space="preserve">
    <value>Ajuster les combinaisons</value>
  </data>
  <data name="cbAutoDetectScrollEnd.Text" xml:space="preserve">
    <value>Détecter la fin du défilement</value>
  </data>
  <data name="tpOutput.Text" xml:space="preserve">
    <value>Résultat</value>
  </data>
  <data name="lblImageCount.Text" xml:space="preserve">
    <value>Nombre d'images:</value>
  </data>
  <data name="gbTrimEdges.Text" xml:space="preserve">
    <value>Ajuster les contours:</value>
  </data>
  <data name="lblCombineVertical.Text" xml:space="preserve">
    <value>Vertical:</value>
  </data>
  <data name="btnResetCombine.Text" xml:space="preserve">
    <value>Réinitialiser les options de résultat</value>
  </data>
  <data name="btnStartTask.Text" xml:space="preserve">
    <value>Mettre en ligne/enregistrer en fonction des paramètres "Après la capture"</value>
  </data>
  <data name="lblMaximumScrollCount.Text" xml:space="preserve">
    <value>Nombre maximum de défilements:</value>
  </data>
  <data name="$this.Text" xml:space="preserve">
    <value>ShareX - Capture avec défilements</value>
  </data>
  <data name="lblScrollMethod.Text" xml:space="preserve">
    <value>Méthode de défilement:</value>
  </data>
  <data name="cbStartCaptureAutomatically.Text" xml:space="preserve">
    <value>Commencer la capture avec défilements immédiatement après la sélection de la région à capturer</value>
  </data>
  <data name="cbStartSelectionAutomatically.Text" xml:space="preserve">
    <value>Démarrer la sélection de la région à capture avant d'ouvrir cette fenêtre</value>
  </data>
  <data name="btnSelectHandle.Text" xml:space="preserve">
    <value>Sélectionner la fenêtre à faire défiler...</value>
  </data>
  <data name="btnSelectRectangle.Text" xml:space="preserve">
    <value>(Optionnel) Sélectionner une région personnalisée dans la fenêtre...</value>
  </data>
  <data name="lblStartDelay.Text" xml:space="preserve">
    <value>Départ différé:</value>
  </data>
  <data name="lblScrollDelay.Text" xml:space="preserve">
    <value>Délai des défilements:</value>
  </data>
  <data name="lblNote.Text" xml:space="preserve">
    <value>Merci de noter que même si ShareX fait de son mieux pour rendre la capture avec défilements précise, il n'est pas possible de capturer correctement tous les contenus avec défilement. Les principales raisons qui peuvent causer des problèmes pendant la combinaison sont des mouvements sur l'écran lors de la capture. Ex: si une page web a des GIF animés ou des objets statiques sur l'écran pendant le défilement (par exemple un menu statique ou des boutons qui ne changent pas leur position alors que le reste de la page Web défile).</value>
  </data>
  <data name="cbAutoCombine.Text" xml:space="preserve">
    <value>Deviner automatiquement les décalages et combiner les images</value>
  </data>
  <data name="btnGuessCombineAdjustments.Text" xml:space="preserve">
    <value>Deviner les ajustement des combinaisons et combiner</value>
  </data>
  <data name="btnGuessEdges.Text" xml:space="preserve">
    <value>Deviner les valeurs des contours à ajuster</value>
  </data>
  <data name="lblCombineLastVertical.Text" xml:space="preserve">
    <value>Dernière image:</value>
  </data>
  <data name="chkAutoUpload.Text" xml:space="preserve">
    <value>Mettre en ligne/enregistrer en fonction des paramètres 'Après la capture'</value>
  </data>
  <data name="gbBeforeCapture.Text" xml:space="preserve">
    <value>Avant la capture</value>
  </data>
  <data name="gbWhileCapturing.Text" xml:space="preserve">
    <value>Pendant la capture</value>
  </data>
  <data name="gbAfterCapture.Text" xml:space="preserve">
    <value>Après la capture</value>
  </data>
  <data name="cbAutoClose.Text" xml:space="preserve">
    <value>Fermer cette fenêtre après le traitement</value>
  </data>
  <data name="lblScrollTopMethodBeforeCapture.Text" xml:space="preserve">
    <value>Méthode de défilement vers le haut avant la capture:</value>
  </data>
</root>